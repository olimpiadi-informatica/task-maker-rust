use std::fs::File;
use std::io::{BufWriter, Write};
use std::path::{Path, PathBuf};
use std::sync::Arc;

use anyhow::{bail, ensure, Context, Error, Result};
use itertools::Itertools;
use task_maker_lang::GraderMap;

use super::italian_yaml::TaskYAML;
use crate::ioi::italian_yaml::{TaskYAMLOrig, TM_ALLOW_DELETE_COOKIE};
use crate::ioi::sanity_checks::get_sanity_checks;
use crate::ioi::{
    make_task_booklets, BatchTypeData, Checker, CommunicationTypeData, IOITask, OutputGenerator,
    TaskType, TestcaseScoreAggregator,
};
use crate::{find_source_file, list_files, EvaluationConfig, WriteBinTo};

pub(in crate::ioi) mod gen_toml;

pub fn parse_task<P: AsRef<Path>>(
    task_dir: P,
    eval_config: &EvaluationConfig,
) -> Result<IOITask, Error> {
    let task_dir = task_dir.as_ref();

    let task_toml_path = task_dir.join("task.toml");

    ensure!(
        task_toml_path.exists(),
        "No task.toml found in {}",
        task_dir.display()
    );

    let config_contents = std::fs::read_to_string(&task_toml_path)
        .with_context(|| format!("Cannot open task.toml from {}", task_toml_path.display()))?;
    let config_orig: TaskYAMLOrig =
        toml::from_str(&config_contents).context("Failed to deserialize task.toml")?;
    let config = config_orig.into_task_yaml(task_dir);

    debug!("The config is {config:#?}");

    let map_file = |file: String| -> Option<PathBuf> {
        match file.as_ref() {
            "" => None,
            _ => Some(file.into()),
        }
    };
    let infile = map_file(config.infile.clone());
    let outfile = map_file(config.outfile.clone());

    let graders = list_files(task_dir, vec!["sol/grader.*", "sol/stub.*"]);
    let grader_map = Arc::new(GraderMap::new(graders));
    debug!("The graders are: {grader_map:#?}");

    let task_type = if let Some(comm) = parse_communication_task_data(task_dir, &config)? {
        comm
    } else {
        parse_batch_task_data(task_dir, grader_map.clone())?
    };

    let (subtasks, testcases) = gen_toml::parse(task_dir, &config, grader_map.clone())?;

    let mut config = config;
    let testcase_score_aggregator = config.score_type.unwrap_or(TestcaseScoreAggregator::Min);
    config.score_type = Some(testcase_score_aggregator);

    let task_yaml_path = task_dir.join("task.yaml");
    if !eval_config.dry_run {
        config.score_type_parameters = Some(
            subtasks
                .iter()
                .sorted_by_key(|(id, _)| *id)
                .map(|(_, st)| {
                    let testcases = st
                        .testcases
                        .iter()
                        .map(|tc_num| format!("{tc_num:03}"))
                        .join("|");
                    (st.max_score, testcases)
                })
                .collect(),
        );

        let n_input = subtasks
            .iter()
            .flat_map(|(_, st)| st.testcases.clone())
            .unique()
            .count();
        config.n_input = Some(n_input);

        let file = File::create(&task_yaml_path)
            .with_context(|| format!("Cannot open task.yaml from {}", task_yaml_path.display()))?;
        let mut buf_file = BufWriter::new(file);
        writeln!(buf_file, "# Generated by task-maker. Do not edit!")?;
        writeln!(buf_file, "# {TM_ALLOW_DELETE_COOKIE}")?;
        writeln!(buf_file, "# Removing or changing the line above will prevent task-maker from touching this file again.")?;
        serde_yaml::to_writer(buf_file, &config).context("Failed to serialize task.yaml")?;
    }

    let mut task = IOITask {
        path: task_dir.into(),
        task_type,
        name: config.name,
        title: config.title,
        time_limit: config.time_limit,
        memory_limit: config.memory_limit,
        infile,
        outfile,
        testcase_score_aggregator,
        score_precision: config.score_precision,
        subtasks,
        testcases,
        grader_map,
        booklets: Vec::new(),
        difficulty: config.difficulty,
        syllabus_level: config.syllabuslevel,
        sanity_checks: Arc::new(get_sanity_checks(
            &eval_config
                .disabled_sanity_checks
                .iter()
                .map(String::as_str)
                .collect::<Vec<_>>(),
        )),
        input_validator_generator: Default::default(),
    };
    // split the creation of the task because make_booklets need an instance of Task
    if !eval_config.no_statement {
        task.booklets =
            make_task_booklets(&task, eval_config).context("Failed to make booklets")?;
    }
    Ok(task)
}

/// Search for a valid output generator (aka official solution) inside the task directory.
fn detect_output_generator(task_dir: &Path, grader_map: Arc<GraderMap>) -> Result<OutputGenerator> {
    let mut official_solutions = find_source_file(
        task_dir,
        vec!["sol/solution.*"],
        task_dir,
        "Official solution at",
        Some(grader_map),
        WriteBinTo::path("bin/official_solution"),
    );
    if official_solutions.len() > 1 {
        let paths = official_solutions
            .iter()
            .map(|s| s.name())
            .collect::<Vec<_>>();
        bail!("Multiple official solutions found: {:?}", paths);
    }
    if official_solutions.is_empty() {
        bail!("No official solution found");
    }
    let official_solution = Arc::new(official_solutions.pop().unwrap());
    debug!("Detected output generator: {official_solution:?}");
    Ok(OutputGenerator::Custom(official_solution.clone(), vec![]))
}

/// Parse the task components relative to the batch task type.
fn parse_batch_task_data(task_dir: &Path, grader_map: Arc<GraderMap>) -> Result<TaskType, Error> {
    let mut checkers = find_source_file(
        task_dir,
        vec!["check/checker.*"],
        task_dir,
        "Checker at",
        None,
        WriteBinTo::WithoutExtension,
    );
    if checkers.len() > 1 {
        let paths = checkers.iter().map(|s| s.name()).collect::<Vec<_>>();
        bail!("Multiple checkers found: {:?}", paths)
    }
    let checker = checkers
        .pop()
        .map(|mut c| {
            // Always copy the custom checker.
            c.copy_exe();

            // Link the checker statically. This makes sure that it will work also outside this machine.
            c.link_static();

            Checker::Custom(Arc::new(c))
        })
        .unwrap_or(Checker::WhiteDiff);

    let official_solution = detect_output_generator(task_dir, grader_map)
        .context("Failed to detect output generator")?;
    Ok(TaskType::Batch(BatchTypeData {
        output_generator: Some(official_solution),
        checker,
    }))
}

/// Parse the task components relative to the communication task type.
fn parse_communication_task_data(
    task_dir: &Path,
    yaml: &TaskYAML,
) -> Result<Option<TaskType>, Error> {
    let mut managers = find_source_file(
        task_dir,
        vec!["check/manager.*"],
        task_dir,
        "Communication manager at",
        None,
        WriteBinTo::WithoutExtension,
    );
    if managers.len() > 1 {
        let paths = managers.iter().map(|s| s.name()).collect::<Vec<_>>();
        bail!("Multiple managers found: {:?}", paths);
    }
    let mut manager = if let Some(manager) = managers.pop() {
        manager
    } else {
        return Ok(None);
    };

    // Always copy the manager.
    manager.copy_exe();

    // Link the manager statically. This makes sure that it will work also outside this machine.
    manager.link_static();

    Ok(Some(TaskType::Communication(CommunicationTypeData {
        manager: Arc::new(manager),
        num_processes: yaml.num_processes.unwrap_or(1),
        user_io: yaml.user_io,
    })))
}
